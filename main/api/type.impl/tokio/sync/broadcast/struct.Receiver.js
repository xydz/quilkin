(function() {
    var type_impls = Object.fromEntries([["quilkin",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","quilkin::config::filter::FilterChangedSubscriber"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Drop-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/drop/trait.Drop.html\" title=\"trait core::ops::drop::Drop\">Drop</a> for Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/drop/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/drop/trait.Drop.html#tymethod.drop\">Read more</a></div></details></div></details>","Drop","quilkin::config::filter::FilterChangedSubscriber"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of messages that were sent into the channel and that\nthis <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> has yet to receive.</p>\n<p>If the returned value from <code>len</code> is larger than the next largest power of 2\nof the capacity of the channel any call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a> will return an\n<code>Err(RecvError::Lagged)</code> and any call to <a href=\"crate::sync::broadcast::Receiver::try_recv\"><code>try_recv</code></a> will return an\n<code>Err(TryRecvError::Lagged)</code>, e.g. if the capacity of the channel is 10,\n<a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a> will start to return <code>Err(RecvError::Lagged)</code> once <code>len</code> returns\nvalues larger than 16.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx1) = broadcast::channel(<span class=\"number\">16</span>);\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n\n    <span class=\"macro\">assert_eq!</span>(rx1.len(), <span class=\"number\">2</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.len(), <span class=\"number\">1</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.len(), <span class=\"number\">0</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns true if there aren’t any messages in the channel that the [<code>Receiver</code>]\nhas yet to receive.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx1) = broadcast::channel(<span class=\"number\">16</span>);\n\n    <span class=\"macro\">assert!</span>(rx1.is_empty());\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n\n    <span class=\"macro\">assert!</span>(!rx1.is_empty());\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    <span class=\"macro\">assert!</span>(rx1.is_empty());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.same_channel\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">same_channel</a>(&amp;self, other: &amp;Receiver&lt;T&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if receivers belong to the same channel.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, rx) = broadcast::channel::&lt;()&gt;(<span class=\"number\">16</span>);\n    <span class=\"kw\">let </span>rx2 = tx.subscribe();\n\n    <span class=\"macro\">assert!</span>(rx.same_channel(<span class=\"kw-2\">&amp;</span>rx2));\n\n    <span class=\"kw\">let </span>(_tx3, rx3) = broadcast::channel::&lt;()&gt;(<span class=\"number\">16</span>);\n\n    <span class=\"macro\">assert!</span>(!rx3.same_channel(<span class=\"kw-2\">&amp;</span>rx2));\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sender_strong_count\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">sender_strong_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of [<code>Sender</code>] handles.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sender_weak_count\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">sender_weak_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of [<code>WeakSender</code>] handles.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_closed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_closed</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if a channel is closed.</p>\n<p>This method returns <code>true</code> if the channel has been closed. The channel is closed\nwhen all <a href=\"crate::sync::broadcast::Sender\"><code>Sender</code></a> have been dropped.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, rx) = broadcast::channel::&lt;()&gt;(<span class=\"number\">10</span>);\n    <span class=\"macro\">assert!</span>(!rx.is_closed());\n\n    drop(tx);\n\n    <span class=\"macro\">assert!</span>(rx.is_closed());\n}</code></pre></div>\n</div></details></div></details>",0,"quilkin::config::filter::FilterChangedSubscriber"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Receiver&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.resubscribe\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">resubscribe</a>(&amp;self) -&gt; Receiver&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Re-subscribes to the channel starting from the current tail element.</p>\n<p>This [<code>Receiver</code>] handle will receive a clone of all values sent\n<strong>after</strong> it has resubscribed. This will not include elements that are\nin the queue of the current receiver. Consider the following example.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n  <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">2</span>);\n\n  tx.send(<span class=\"number\">1</span>).unwrap();\n  <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>rx2 = rx.resubscribe();\n  tx.send(<span class=\"number\">2</span>).unwrap();\n\n  <span class=\"macro\">assert_eq!</span>(rx2.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">2</span>);\n  <span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">1</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.recv\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">recv</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Receives the next value for this receiver.</p>\n<p>Each <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> handle will receive a clone of all values sent\n<strong>after</strong> it has subscribed.</p>\n<p><code>Err(RecvError::Closed)</code> is returned when all <code>Sender</code> halves have\ndropped, indicating that no further values can be sent on the channel.</p>\n<p>If the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> handle falls behind, once the channel is full, newly\nsent values will overwrite old values. At this point, a call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a>\nwill return with <code>Err(RecvError::Lagged)</code> and the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a>’s\ninternal cursor is updated to point to the oldest value still held by\nthe channel. A subsequent call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a> will return this value\n<strong>unless</strong> it has been since overwritten.</p>\n<h5 id=\"cancel-safety\"><a class=\"doc-anchor\" href=\"#cancel-safety\">§</a>Cancel safety</h5>\n<p>This method is cancel safe. If <code>recv</code> is used as the event in a\n<a href=\"crate::select\"><code>tokio::select!</code></a> statement and some other branch\ncompletes first, it is guaranteed that no messages were received on this\nchannel.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx1) = broadcast::channel(<span class=\"number\">16</span>);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>rx2 = tx.subscribe();\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n        <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    });\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"macro\">assert_eq!</span>(rx2.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n        <span class=\"macro\">assert_eq!</span>(rx2.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    });\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n}</code></pre></div>\n<p>Handling lag</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">2</span>);\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n    tx.send(<span class=\"number\">30</span>).unwrap();\n\n    <span class=\"comment\">// The receiver lagged behind\n    </span><span class=\"macro\">assert!</span>(rx.recv().<span class=\"kw\">await</span>.is_err());\n\n    <span class=\"comment\">// At this point, we can abort or continue with lost messages\n\n    </span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">20</span>, rx.recv().<span class=\"kw\">await</span>.unwrap());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">30</span>, rx.recv().<span class=\"kw\">await</span>.unwrap());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_recv\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_recv</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, TryRecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to return a pending value on this receiver without awaiting.</p>\n<p>This is useful for a flavor of “optimistic check” before deciding to\nawait on a receiver.</p>\n<p>Compared with <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a>, this function has three failure cases instead of two\n(one for closed, one for an empty buffer, one for a lagging receiver).</p>\n<p><code>Err(TryRecvError::Closed)</code> is returned when all <code>Sender</code> halves have\ndropped, indicating that no further values can be sent on the channel.</p>\n<p>If the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> handle falls behind, once the channel is full, newly\nsent values will overwrite old values. At this point, a call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a>\nwill return with <code>Err(TryRecvError::Lagged)</code> and the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a>’s\ninternal cursor is updated to point to the oldest value still held by\nthe channel. A subsequent call to <a href=\"crate::sync::broadcast::Receiver::try_recv\"><code>try_recv</code></a> will return this value\n<strong>unless</strong> it has been since overwritten. If there are no values to\nreceive, <code>Err(TryRecvError::Empty)</code> is returned.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">16</span>);\n\n    <span class=\"macro\">assert!</span>(rx.try_recv().is_err());\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n\n    <span class=\"kw\">let </span>value = rx.try_recv().unwrap();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">10</span>, value);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.blocking_recv\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">blocking_recv</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Blocking receive to call outside of asynchronous contexts.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function panics if called within an asynchronous execution\ncontext.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">16</span>);\n\n    <span class=\"kw\">let </span>sync_code = thread::spawn(<span class=\"kw\">move </span>|| {\n        <span class=\"macro\">assert_eq!</span>(rx.blocking_recv(), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">10</span>));\n    });\n\n    <span class=\"kw\">let _ </span>= tx.send(<span class=\"number\">10</span>);\n    sync_code.join().unwrap();\n}</code></pre></div>\n</div></details></div></details>",0,"quilkin::config::filter::FilterChangedSubscriber"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[20357]}